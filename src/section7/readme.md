# 원자적 연산
## 원자적 연산이란?
```java
Object a = new Object();
```
- 프로그래밍에서 어떤 연산이 수행되는 도중에 중간에 끼어들 수 없고, 오직 완전하 끝나거나 안하거나 둘 중 하나인 상태를 의미한다.
- 즉, 한 번의 동작으로 끝나는 연산이며, 중간값이 존재하지 않는다.
  - 따라서 다른 스레드의 개입으로 인해 중간 연산 결과에 문제가 생길 수 없다. 
    - 아무 문제없이 온전히 끝나거나 아니거나 둘 중 하나이다.
  - 반대로 여러 단계로 나뉘어져 다른 스레드의 영향을 받는 연산을 원자적이지 않다고 말한다.  
- 참고로 `++` 연산은 `get -> 연산 작업(set)`이 들어가기 때문에 원자적 연산이 아니다. 
- 모든 참조값(주소) 할당은 원자적 연산이다.
  - `Object a = new Object();`
    - 메모리에 객체를 생성하고 그 객체의 주소값을 생성하여 변수에 할당한다.
    - 참조값 할당은 참조값(주소)을 변수 `a`에 할당하는 것뿐이므로 원자적이다.
- `long`, `double`을 제외한 나머지 기본 타입은 원자적 연산에 해당한다.
  - 자바에서 JVM은 32 비트 이하 크기인 타입 경우 원자적으로 처리할 수 있다.
  - 그러나,`long`, `double`의 크기는 64 비트이기 때문에 2 번 나눠서 처리해야 한다.
  - 따라서 복수의 CPU 명령어가 필요하며 그 사이에 다른 스레드가 끼어들 가능성이 생긴다.

## `volatile`
- 이를 해결하기 위해 자바에서는 `volatile` 키워드를 제공한다.
  - 이 키워드를 사용하면 해당 변수의 메인 메모리에서 최신값을 읽고 쓰게 하도록 강제한다.
  - 자바는 성능을 위해 변수 값을 cpu 캐시에 저장해두는 경우가 있다.
  - 스레드 A가 변수 `x`를 10으로 바꿔도, 스레드 B에서는 캐시값을 읽어 이전 `x` 값을 보고 있을 수 있다.
  - `volatile`을 사용하면 항상 메인 메모리에서 최신값을 읽기 때문에 스레드 간 가시성이 보장된다.
  - 또한 CPU나 컴파일러가 성능 향상을 위해 사용하는 명령어 순서 재정렬을 방지해준다.

# Race Condition & Data Race
## Race Condition
- 둘 이상의 스레드가 동시에 공유 자원에 접근하면서 실행 순서에 따라 잘못된 결과가 발생할 수 있는 상황이다.
  - 예를 들어 통장 잔고에는 1000원이 들어가있음.
    - 스레드 X에서 잔고 확인 1000원
    - 스레드 Y에서 잔고 확인 1000원
    - 스레드 X에서 사과를 구매하여 500원 차감, 남은 금액 500원
    - 스레드 Y에서 배를 구매하여 300원 차감, 남은 금액 700원
    - 스레드 Y에서 남은 금액 저장, 남은 금액 700원
    - 스레드 X에서 저장 남은 금액 저장, 남은 금액 500원으로 스레드 Y의 결과가 씹힌다.
    - 이 예는 스레드 실행 순서에 따라 다양한 경우의 문제가 발생한다.

## Data Race
```java
public class SharedData {
    int x = 0;
    int y = 0;

    public void update() {
        x++;
        y++;
    }

    public void check() {
        if (y > x) {
            System.out.println("Data race detected!");
        }
    }
}
```
- Race Condition의 특정한 형태로 두 개 이상의 스레드가 공유 변수에 최소 하나는 쓰기(write) 연산을 하면서 적절한 동기화 없이 동시에 접근하는 상황을 말한다.
- 위 코드에서 `update()`와 `check()`가 서로 다른 스레드에서 실행되면 `y > x`인 순간이 발생 가능하다.


### 명령어 재정렬
- CPU나 컴파일러가 성능 향상을 위해 코드의 실행 순서를 바꾸는 것을 말한다.
- ```java
  int x = 1;
  int y = x;
  ```
  - 위와 같은 코드는 순차적으로 실행되어야 결과에 영향이 없기 때문에 연산 순서가 보장된다.
- ```java
  int a = 1;
  int b = 1;
  ```
  - 그러나, 이 두 줄은 서로에게 영향을 주지 않기 때문에 비순차적인 연산을 허용한다.

### 해결 방법
- `synchronized` 임계 구역(Critical Section)에 대해 단일 스레드만 접근할 수 있게 하여, 원자성, 가시성, 재정렬 방지 모두 보장한다.
  - 명령어 재정렬을 통한 실행 순서가 달라져도 싱글 스레드와 같이 동시 실행이 안되므로 문제없다.
- `volatile` 키워드는 락을 사용하지 않고도 가시성 보장과 재정렬 방지를 통해 일정 수준의 순서 보장을 제공한다. 
  - 하지만 복합 연산에서는 여전히 race condition이 발생할 수 있으므로, 단순 플래그나 상태 전파용으로 적합하다.
